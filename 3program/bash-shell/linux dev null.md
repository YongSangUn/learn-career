<span id ="jump"><font size=5>目录：</font></span>

[toc]

<a href="#bottom" target="_self"><p align="right"><u>前往底部</u></p></a>

> 原文地址：https://blog.csdn.net/reyleon/article/details/11595985

### Shell中的>/dev/null 2>&1 与 2>&1 >/dev/null 与&>/dev/null 的区别

默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的文件描述符是0，1，2 。那么我们来看看下面的几种重定向方法的区别：

```bash
一、>/dev/null 2>&1
```

// 实际上，应该等同于这样： 1>/dev/null 2>/dev/null ，默认情况下就是1，标准输出，所以一般都省略。 而&符号，后面接的是必须的文件描述符。不能写成2>1，这样就成了标准错误重定向到文件名为1的文件中了，而不是重定向标准错误到标准输出中。所以这里就是：标准输出重定向到了/dev/null，而标准错误又重定向到了标准输出，所以就成了标准输出和标准错误都重定向到了/dev/null

```bash
二、2>&1 >/dev/null
```

// 咋一看，这个跟上面那个有啥区别呢，不也是标准错误重定向到标准输出，而标准输出重定向到/dev/null么？ 最后不应该都重定向/dev/null么？ 我是这么理解的！一条指令同一时刻要么产生标准错误，要么产生标准输出。 当产出标准错误的时候，因这个标准错误重定向到了标准输出，而标准输出是输出到屏幕。这个时候标准输出还没有被重定向到/dev/null，于是在屏幕上打印了。当产生标准输出时，那么它就不是标准错误，2>&1无效，于是标准输出重定向dev/null，不打印到屏幕。所以最终结果将是：标准错误打印到屏幕，而标准输出不打印到屏幕。

-------------

2016-01-22 更新

突然看到N年前的博客, 才发现错误百出.更新下, 以免误人, 事实上, 命令行的重定向什么的, 是在执行命令之前就准备好了的. 解释顺序从左至右依次进行, 2&>1 ,而1是屏幕, 所以标准错误重定向到屏幕, 再而 1>/dev/null , 即标准输出重定向到 /dev/null, 上述2>&1 >/dev/null 并不是什么同一时刻要么产生标准输出要么产生标准错误. 而是两个不同的东西.
以以下变量的方式做个解释，就很明显了，这两种方式是不同的，前者就像：

```bash
a=1
b=a
```

而后者就像：

```c
b=a
a=1
```

```c
三、&>/dev/null
```

这个就是，不管你是啥玩意儿文件描述符，通通重定向到/dev/null

<a href="#jump" target="_self"><p align="right"><u>返回顶部</u></p></a>
<span id="bottom"></span>










